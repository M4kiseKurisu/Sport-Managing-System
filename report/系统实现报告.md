# 系统实现报告

## 一、系统结构设计

我们的系统采用前后端与数据库的分离的架构。数据库作为数据的存储和管理中心，后端利用存储过程或直接执行SQL命令与数据库交互，并将数据传递给前端。后端同时负责接收、处理前端请求，并将请求转发至数据库。前端则专注于用户界面的展示和用户交互，将数据库中的数据呈现给用户，并接收用户对数据的修改请求，将其传递给后端处理。具体实现环境包括。

### 1.1 体系结构

此系统应用采用了前端、后端、数据库分离的体系结构。数据库层次负责存储、管理数据；后端层次根据前端请求，与数据库做交互，对数据库的数据进行增删改查，并进行处理，按需传给前端；前端层次根据后端传入的数据，展示渲染页面，并与用户交互，依据用户的操作向后端发送请求。

#### 1.1.1 系统实现环境

**前端**：

**后端**：采用 Django 框架，使用 Python 开发语言。

依赖包：

```
Django              4.2.6
django-cors-headers 4.3.0
mysqlclient         2.2.0
Pillow              10.1.0
PyMySQL             1.1.0
```

**数据库**：使用华为 GaussDB 云数据库，支持 MySQL 语法。

#### 1.1.2 前端结构

#### 1.1.3 后端结构

后端的文件结构如下：

```
├─api                 存放和数据库有关的代码
│  ├─ migrations      存放数据库迁移文件
│  ├─ system          存放系统配置函数，包括上传图片的重命名方法
│  └─ views           存放处理请求并返回响应的视图代码
│     ├─ entity       存放数据库实体表有关的代码
│     ├─ relation     存放数据库联系表有关的代码
│     └─ util         工具包
├─backend             Django 配置
└─media               保存上传的文件
    └─images          存放前端上传的图片
```

### 1.2 功能结构

<img src=".\images\系统功能结构图.drawio.png" style="zoom:75%;" />

本系统拥有注册登录、用户主页、活动、团体、器材、通知、动态和好友八个功能模块。
- **注册登录**
    - 登录已有账号；
    - 注册新账号。
- **用户主页**
    - 修改个人信息：包括姓名、年龄、性别、个人简介等；
    - 上传头像：上传并修改自己的头像；
    - 统计团体：统计自己参加的团体，并以环装图形式展示；
    - 统计活动：统计自己参加的活动，并以环装图形式展示。
- **活动**<br>
    活动功能有两个大模块，分别是活动列表和我的活动。
    - **活动列表**
        - 查看热门活动：系统会根据用户的参加记录和创建记录为你推送6个活动，以走马灯形式展现；
        - 活动信息：用户可以查看所有有权限查看的活动；
        - 筛选活动：用户可以通过时间、类型关键字等方法筛选活动
        - 参加活动：用户可以在列表参加自己感兴趣的活动；
        - 过往活动：用户可以浏览已经结束的活动并点赞。
    - **我的活动**
        - 查看详情：可以点击查看活动详细信息，并给自己已经结束的活动点赞；
        - 退出活动：退出用户参加的活动；
        - 发布活动动态：可以给已结束的活动发布动态，动态可以选择可见性，上传图片和文本；
        - 创建活动。
- **团体**<br>
    团体有团体中心、你的团体、团体详情和团体申请四个部分。
    - **团体中心**
        - 查看所有团体；
        - 创建团体；
        - 查看团体信息：跳转该团体的详情页；
        - 搜索团体：使用模糊匹配搜索团体；
        - 申请团体：向团体提交申请，并返回失败信息或成功信息。
    - **你的团体**
        - 退出团体：退出用户加入的团体或着退出并解散你创建的团体；
        - 查看团体信息：跳转该团体的详情页。
    - **团体详情**
        - 团体基本信息：团体图片、团体名称等；
        - 查看团体活动：查看团体举办的活动，并以环装图形式展示；
        - 查看团体成员。
    - **团体申请**
      - 查看过往申请：查看所有你发送的申请；
      - 审批申请：审批你的权限为管理员或创建者的团体的申请。
- **通知**
    - 删除通知；
    - 查看通知，通知包括所属团体、所属活动、好友申请等事件。
- **器材**
    - 器材信息：展示器材的说明，租界情况等；
    - 个人(团体)租借器材：以个人或自己创建的团体的名义租借器材；
    - 查看租借情况：查看个人或所有自己加入的团体的租借情况；
    - 搜索(筛选团体)：用户可以通过时间、类型关键字等方法筛选或搜索团体。
- **好友**
    - 添加好友；
    - 处理好友申请：拒绝或接收好友申请；
    - 好友信息：展示好友名字、个性签名；
    - 删除好友。
- **动态**
    - 点赞动态：点赞自己可见的动态；
    - 浏览动态：可以切换所有动态和个人动态；
    - 删除动态：删除自己发布的动态；
    - 跳转链接活动：每个动态都有一个链接一个活动，可以跳转至活动主页。


<br>

## 二、数据库基本表的定义

在后端数据库实现中，我们选择采用 Django 中的 ORM 技术，在 `models.py` 文件中定义了 7 个实体表和 11 个联系表，这些表的结构和关系都通过类继承 `models.Model` 来定义，并且利用 ORM 提供的语法来定义了数据库表的类型、约束和关系。通过 ORM，能够以面向对象的方式来操作数据库，简化了数据库操作的编程过程，并提高了开发效率。

### 2.1 实体表

**用户表：** 管理用户个人信息。

|  属性名  |     字段名     |   数据类型   |       约束       |
| :------: | :------------: | :----------: | :--------------: |
|    ID    |      uid       |     int      |   PRIMARY KEY    |
|   账号   |    account     | varchar(32)  | NOT NULL、UNIQUE |
|   密码   |    password    | varchar(32)  |     NOT NULL     |
|   姓名   |   user_name    | varchar(10)  |     NOT NULL     |
|   性别   |  user_gender   |   smallint   |     NOT NULL     |
|   年龄   |    user_age    |     int      |     NOT NULL     |
| 个人签名 | user_signature | varchar(128) |     NOT NULL     |
| 电话号码 |  phone_number  |    bigint    | NOT NULL、UNIQUE |
|   邮箱   |     email      | varchar(32)  | NOT NULL、UNIQUE |
|   头像   |    picture     | varchar(100) |                  |

```python
class User(models.Model):
    """ 用户实体表 """
    USER_GENDER = (
        (0, '女'),
        (1, '男'),
    )
    uid = models.IntegerField(primary_key=True)
    account = models.CharField(max_length=32, unique=True)
    password = models.CharField(max_length=32)
    user_name = models.CharField(max_length=10)
    user_age = models.IntegerField()
    user_gender = models.SmallIntegerField(choices=USER_GENDER)
    phone_number = models.BigIntegerField(unique=True)
    email = models.EmailField(max_length=32, unique=True)
    user_signature = models.CharField(max_length=128, default="", blank=True)
    picture = models.ImageField(upload_to='images/user/', storage=ImageStorage(), null=True)
```

**团体表：** 管理团体的基本信息。

|  属性名  |   字段名   |   数据类型   |       约束       |
| :------: | :--------: | :----------: | :--------------: |
|    ID    |    gid     |     int      |   PRIMARY KEY    |
|   名称   | group_name | varchar(32)  | NOT NULL、UNIQUE |
|   描述   | group_desc | varchar(128) |     NOT NULL     |
| 团体图片 |  picture   | varchar(100) |                  |
| 人数限制 |  maximum   |     int      |     NOT NULL     |
| 成员人数 |  capacity  |     int      |     NOT NULL     |
|   标签   |    tag     | varchar(32)  |     NOT NULL     |
|  创建人  |  creator   |     int      |   FOREIGN KEY    |

```python
class Group(models.Model):
    """ 团体实体表 """
    gid = models.IntegerField(primary_key=True)
    creator = models.ForeignKey(User, on_delete=models.CASCADE)
    group_name = models.CharField(max_length=32, unique=True)
    group_desc = models.CharField(max_length=128)
    tag = models.CharField(max_length=32)
    maximum = models.IntegerField()
    capacity = models.IntegerField()
    picture = models.ImageField(upload_to='images/group/', storage=ImageStorage(), null=True)
```

**器材表：** 管理器材实体的基本信息。

|  属性名  |  字段名  |   数据类型   |       约束       |
| :------: | :------: | :----------: | :--------------: |
|    ID    |   eid    |     int      |   PRIMARY KEY    |
|   类别   | category | varchar(32)  | NOT NULL、UNIQUE |
|   数量   |  amount  |     int      |     NOT NULL     |
| 器材图片 | picture  | varchar(100) |                  |

```python
class Equipment(models.Model):
    """ 器材实体表 """
    eid = models.IntegerField(primary_key=True)
    category = models.CharField(max_length=32, unique=True)
    amount = models.IntegerField(default=0)
    picture = models.ImageField(upload_to='images/equipment/', storage=ImageStorage(), null=True)
```

**场地表：** 管理场地的基本信息。

|  属性名  |   字段名   |  数据类型   |       约束       |
| :------: | :--------: | :---------: | :--------------: |
|    ID    |    fid     |     int     |   PRIMARY KEY    |
|   位置   |  location  | varchar(32) | NOT NULL、UNIQUE |
|   类别   |  category  | varchar(16) |     NOT NULL     |
| 开始时间 | open_time  |   time(6)   |     NOT NULL     |
| 结束时间 | close_time |   time(6)   |     NOT NULL     |
| 项目限制 |   limit    | tinyint(1)  |     NOT NULL     |

```python
class Field(models.Model):
    """ 运动场地实体表 """
    fid = models.IntegerField(primary_key=True)
    location = models.CharField(max_length=32, unique=True)
    category = models.CharField(max_length=16, db_index=True)
    limit = models.BooleanField()
    open_time = models.TimeField()
    close_time = models.TimeField()
```

**活动表：** 管理活动基本信息。

|    属性名    |    字段名    |   数据类型   |    约束     |
| :----------: | :----------: | :----------: | :---------: |
|      ID      |     aid      |     int      | PRIMARY KEY |
|   活动名称   |     name     | varchar(32)  |  NOT NULL   |
|   活动描述   |     desc     | varchar(128) |  NOT NULL   |
|   活动图片   |   picture    | varchar(100) |             |
| 活动人数限制 |   maximum    |     int      |  NOT NULL   |
|   参与人数   |   capacity   |     int      |  NOT NULL   |
|   活动类型   |   category   | varchar(32)  |  NOT NULL   |
|     标签     |     tags     | varchar(128) |  NOT NULL   |
|  创建者类型  | creator_type |   smallint   |  NOT NULL   |
|    获赞数    |    favor     |     int      |  NOT NULL   |
|    私有性    |   private    |  tinyint(1)  |  NOT NULL   |

```python
class Activity(models.Model):
    """ 活动项目实体表 """
    TYPE = (
        (0, "个人"),
        (1, "团体"),
    )
    aid = models.IntegerField(primary_key=True)
    type = models.SmallIntegerField(choices=TYPE, db_index=True)
    name = models.CharField(max_length=32, db_index=True)
    desc = models.CharField(max_length=128)
    category = models.CharField(max_length=32, db_index=True)
    tags = models.CharField(max_length=128)
    maximum = models.IntegerField()
    capacity = models.IntegerField()
    favor = models.IntegerField()
    picture = models.ImageField(upload_to='images/activity/', storage=ImageStorage(), null=True)
    private = models.BooleanField()
```

**通知表：** 管理系统通知的基本数据。

|  属性名  |  字段名  |   数据类型   |    约束     |
| :------: | :------: | :----------: | :---------: |
|    ID    |   nid    |     int      | PRIMARY KEY |
| 通知时间 |   time   | datetime(6)  |  NOT NULL   |
| 通知内容 |   text   | varchar(128) |  NOT NULL   |
| 通知对象 | receiver |     int      | FOREIGN KEY |

```python
class Notice(models.Model):
    """ 系统通知表 """
    nid = models.IntegerField(primary_key=True)
    time = models.DateTimeField(auto_now_add=True, db_index=True)
    text = models.CharField(max_length=128)
    receiver = models.ForeignKey(User, on_delete=models.CASCADE)
```

**动态表：** 管理用户发表的动态信息。

|  属性名  |  字段名  |   数据类型   |    约束     |
| :------: | :------: | :----------: | :---------: |
|    ID    |   sid    |     int      | PRIMARY KEY |
| 发布时间 |   time   | datetime(6)  |  NOT NULL   |
| 发布文本 |   text   | varchar(512) |  NOT NULL   |
| 发布图片 | picture  | varchar(100) |             |
|  获赞数  |  favor   |     int      |  NOT NULL   |
|  私有性  | private  |   smallint   |  NOT NULL   |
| 所属用户 |   user   |     int      | FOREIGN KEY |
| 关联活动 | activity |     int      | FOREIGN KEY |

```python
class Stream(models.Model):
    """ 动态表 """
    PRIVACY = (
        (0, "仅自己可见"),
        (1, "好友可见"),
        (2, "所有人可见"),
    )
    sid = models.IntegerField(primary_key=True)
    time = models.DateTimeField(auto_now_add=True, db_index=True)
    text = models.CharField(max_length=512)
    picture = models.ImageField(upload_to='images/stream/', storage=ImageStorage(), null=True)
    favor = models.IntegerField(default=0)
    private = models.SmallIntegerField(choices=PRIVACY)
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    activity = models.ForeignKey(Activity, on_delete=models.CASCADE)
```

### 2.2 联系表

由于 ORM 不支持多个字段共同作为主键，因此没有指定主键的表会自动添加一个自增的 id 字段。

**团体成员表：** 记录团体的成员信息。

|  属性名  | 字段名 | 数据类型 |            约束             |
| :------: | :----: | :------: | :-------------------------: |
|    ID    |   id   |  bigint  | PRIMARY KEY、AUTO_INCREMENT |
|  用户ID  |  uid   |   int    |         FOREIGN KEY         |
|  团体ID  |  gid   |   int    |         FOREIGN KEY         |
| 成员类型 |  type  | smallint |          NOT NULL           |

 `(uid, gid)` 组合添加了唯一约束。

```python
class UserInGroup(models.Model):
    """ 用户从属团体联系表 """
    TYPE = (
        (0, "创建人"),
        (1, "管理员"),
        (2, "成员"),
    )
    uid = models.ForeignKey(User, on_delete=models.CASCADE)
    gid = models.ForeignKey(Group, on_delete=models.CASCADE, db_index=True)
    type = models.SmallIntegerField(choices=TYPE)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['uid', 'gid'], name='unique_user_in_group'),
        ]
```

**团体申请表：** 记录团体的申请信息与审批情况。

|  属性名  |   字段名   |   数据类型   |            约束             |
| :------: | :--------: | :----------: | :-------------------------: |
|    ID    |     id     |    bigint    | PRIMARY KEY、AUTO_INCREMENT |
|  用户ID  |    uid     |     int      |         FOREIGN KEY         |
|  团体ID  |    gid     |     int      |         FOREIGN KEY         |
| 申请内容 |  content   | varchar(128) |          NOT NULL           |
| 申请时间 | apply_time | datetime(6)  |          NOT NULL           |
| 申请状态 |   status   |   smallint   |          NOT NULL           |

`(uid, gid, apply_time)` 组合添加了唯一约束。

```python
class UserApplyGroup(models.Model):
    """ 用户申请团体联系表 """
    STATUS = (
        (0, "申请中"),
        (1, "已接受"),
        (2, "已拒绝"),
    )
    uid = models.ForeignKey(User, on_delete=models.CASCADE)
    gid = models.ForeignKey(Group, on_delete=models.CASCADE, db_index=True)
    content = models.CharField(max_length=128)
    apply_time = models.DateTimeField(auto_now_add=True, db_index=True)
    status = models.SmallIntegerField(choices=STATUS)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['uid', 'gid', 'apply_time'], name='unique_user_apply_group'),
        ]
```

**场地使用情况表：** 记录活动和场地的联系与相关信息。

|  属性名  |   字段名   |  数据类型   |            约束             |
| :------: | :--------: | :---------: | :-------------------------: |
|    ID    |     id     |   bigint    | PRIMARY KEY、AUTO_INCREMENT |
|  活动ID  |    aid     |     int     |         FOREIGN KEY         |
|  场地ID  |    fid     |     int     |         FOREIGN KEY         |
| 起始时间 | start_time | datetime(6) |          NOT NULL           |
| 结束时间 |  end_time  | datetime(6) |          NOT NULL           |

`aid`、`(fid, start_time)` 组合和 `(fid, end_time) `组合添加了唯一约束。

```python
class ActivityUseField(models.Model):
    """ 活动使用场地联系表"""
    aid = models.ForeignKey(Activity, on_delete=models.CASCADE)
    fid = models.ForeignKey(Field, on_delete=models.CASCADE)
    start_time = models.DateTimeField(db_index=True)
    end_time = models.DateTimeField(db_index=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['aid'], name='unique_activity_user_field1'),
            models.UniqueConstraint(fields=['fid', 'start_time'], name='unique_activity_user_field2'),
            models.UniqueConstraint(fields=['fid', 'end_time'], name='unique_activity_user_field3')
        ]
```

**用户参加活动记录表：** 记录活动的参与成员。

| 属性名 | 字段名 |  数据类型  |            约束             |
| :----: | :----: | :--------: | :-------------------------: |
|   ID   |   id   |   bigint   | PRIMARY KEY、AUTO_INCREMENT |
| 用户ID |  uid   |    int     |         FOREIGN KEY         |
| 活动ID |  aid   |    int     |         FOREIGN KEY         |
|  喜欢  |  like  | tinyint(1) |          NOT NULL           |

`(uid, aid)` 组合添加了唯一约束。

```python
class UserInActivity(models.Model):
    """ 用户参加项目联系表 """
    uid = models.ForeignKey(User, on_delete=models.CASCADE, db_index=True)
    aid = models.ForeignKey(Activity, on_delete=models.CASCADE, db_index=True)
    like = models.BooleanField()

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['uid', 'aid'], name='unique_user_in_activity')
        ]
```

**用户创建活动记录表：** 记录个人活动的创建信息。

| 属性名 | 字段名 | 数据类型 |            约束             |
| :----: | :----: | :------: | :-------------------------: |
|   ID   |   id   |  bigint  | PRIMARY KEY、AUTO_INCREMENT |
| 用户ID |  uid   |   int    |         FOREIGN KEY         |
| 活动ID |  aid   |   int    |         FOREIGN KEY         |

`aid`字段添加了唯一约束。

```python
class UserCreateActivity(models.Model):
    """ 用户发起活动联系表 """
    uid = models.ForeignKey(User, on_delete=models.CASCADE)
    aid = models.ForeignKey(Activity, on_delete=models.CASCADE, db_index=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['aid'], name='unique_user_create_activity')
        ]
```

**团体创建活动记录表：** 记录团体活动的创建信息。

|  属性名  | 字段名 | 数据类型 |            约束             |
| :------: | :----: | :------: | :-------------------------: |
|    ID    |   id   |  bigint  | PRIMARY KEY、AUTO_INCREMENT |
|  团体ID  |  gid   |   int    |         FOREIGN KEY         |
| 创建人ID |  uid   |   int    |         FOREIGN KEY         |
|  活动ID  |  aid   |   int    |         FOREIGN KEY         |

`aid`字段添加了唯一约束。

```python
class GroupCreateActivity(models.Model):
    """ 团体发起活动联系表 """
    uid = models.ForeignKey(User, on_delete=models.CASCADE)
    gid = models.ForeignKey(Group, on_delete=models.CASCADE)
    aid = models.ForeignKey(Activity, on_delete=models.CASCADE, db_index=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['aid'], name='unique_group_create_activity')
        ]
```

**用户器材借用表：** 记录个人借用器材的相关信息。

|    属性名    |   字段名    |  数据类型   |            约束             |
| :----------: | :---------: | :---------: | :-------------------------: |
|      ID      |     id      |   bigint    | PRIMARY KEY、AUTO_INCREMENT |
|    器材ID    |     eid     |     int     |         FOREIGN KEY         |
|    用户ID    |     uid     |     int     |         FOREIGN KEY         |
| 借用开始时间 | start_time  | datetime(6) |          NOT NULL           |
| 借用结束时间 |  end_time   | datetime(6) |          NOT NULL           |
|   是否归还   |  is_return  |  smallint   |          NOT NULL           |
|   借用数量   | lend_amount |     int     |          NOT NULL           |

`(eid, uid, start_time, end_time)`组合添加了唯一约束。

```python
class UserEquipment(models.Model):
    """ 用户借用器材联系表 """
    RETURN_STATUS = (
        (0, "未归还"),
        (2, "已归还"),
    )
    eid = models.ForeignKey(Equipment, on_delete=models.CASCADE)
    uid = models.ForeignKey(User, on_delete=models.CASCADE, db_index=True)
    start_time = models.DateTimeField()
    end_time = models.DateTimeField()
    lend_amount = models.IntegerField()
    is_return = models.SmallIntegerField(choices=RETURN_STATUS, default=0)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['eid', 'uid', 'start_time', 'end_time'], name='unique_user_equipment')
        ]
```

**团体器材借用表：** 记录团体借用器材的相关信息。

|    属性名    |   字段名    |  数据类型   |            约束             |
| :----------: | :---------: | :---------: | :-------------------------: |
|      ID      |     id      |   bigint    | PRIMARY KEY、AUTO_INCREMENT |
|    器材ID    |     eid     |     int     |         FOREIGN KEY         |
|    团体ID    |     gid     |     int     |         FOREIGN KEY         |
| 借用开始时间 | start_time  | datetime(6) |          NOT NULL           |
| 借用结束时间 |  end_time   | datetime(6) |          NOT NULL           |
|   是否归还   |  is_return  |  smallint   |          NOT NULL           |
|   借用数量   | lend_amount |     int     |          NOT NULL           |

`(eid, gid, start_time, end_time)`组合添加了唯一约束。

```python
class GroupEquipment(models.Model):
    """ 团体借用器材联系表 """
    RETURN_STATUS = (
        (0, "未归还"),
        (2, "已归还"),
    )
    eid = models.ForeignKey(Equipment, on_delete=models.CASCADE)
    gid = models.ForeignKey(Group, on_delete=models.CASCADE, db_index=True)
    start_time = models.DateTimeField()
    end_time = models.DateTimeField()
    lend_amount = models.IntegerField()
    is_return = models.SmallIntegerField(choices=RETURN_STATUS, default=0)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['eid', 'gid', 'start_time', 'end_time'], name='unique_group_equipment')
        ]
```

**好友联系表：** 记录用户-用户好友联系。

| 属性名  | 字段名 | 数据类型 |            约束             |
| :-----: | :----: | :------: | :-------------------------: |
|   ID    |   id   |  bigint  | PRIMARY KEY、AUTO_INCREMENT |
| 用户ID1 |  uid1  |   int    |         FOREIGN KEY         |
| 用户ID2 |  uid2  |   int    |         FOREIGN KEY         |

`(uid1, uid2)`组合添加了唯一约束。

```python
class Friend(models.Model):
    """ 好友联系表 """
    uid1 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='friends1')
    uid2 = models.ForeignKey(User, on_delete=models.CASCADE, related_name='friends2')

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['uid1', 'uid2'], name='unique_friend')
        ]
```

**好友申请表：** 记录好友申请信息和审批状态。

|  属性名  |   字段名   |   数据类型   |            约束             |
| :------: | :--------: | :----------: | :-------------------------: |
|    ID    |     id     |    bigint    | PRIMARY KEY、AUTO_INCREMENT |
| 申请者ID |   sender   |     int      |         FOREIGN KEY         |
| 接收者ID |  receiver  |     int      |         FOREIGN KEY         |
| 申请内容 |  content   | varchar(128) |          NOT NULL           |
| 申请时间 | apply_time | datetime(6)  |          NOT NULL           |
| 申请状态 |   status   |   smallint   |          NOT NULL           |

`(sender, receiver, apply_time)`组合添加了唯一约束。

```python
class FriendApply(models.Model):
    """ 好友申请表 """
    STATUS = (
        (0, "申请中"),
        (1, "已接受"),
        (2, "已拒绝"),
    )
    sender = models.ForeignKey(User, on_delete=models.CASCADE, related_name='sender')
    receiver = models.ForeignKey(User, on_delete=models.CASCADE, related_name='receiver')
    content = models.CharField(max_length=128)
    apply_time = models.DateTimeField(auto_now_add=True, db_index=True)
    status = models.SmallIntegerField(choices=STATUS)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['sender', 'receiver', 'apply_time'], name='unique_friend_apply')
        ]
```

**动态点赞记录表：** 记录用户点赞动态的先关信息。

| 属性名 | 字段名 | 数据类型 |            约束             |
| :----: | :----: | :------: | :-------------------------: |
|   ID   |   id   |  bigint  | PRIMARY KEY、AUTO_INCREMENT |
| 用户ID |  uid   |   int    |         FOREIGN KEY         |
| 动态ID |  sid   |   int    |         FOREIGN KEY         |

 `(uid, sid)` 组合添加了唯一约束。

```python
class UserFavorStream(models.Model):
    """ 用户点赞动态记录表 """
    uid = models.ForeignKey(User, on_delete=models.CASCADE)
    sid = models.ForeignKey(Stream, on_delete=models.CASCADE, db_index=True)

    class Meta:
        constraints = [
            models.UniqueConstraint(fields=['uid', 'sid'], name='unique_user_favor_stream')
        ]
```

## 三、系统重要功能实现方法

### 3.1 触发器

合理使用数据库触发器可以防⽌产生异常数据。本项目中主要对删除操作设置触发器，保证数据的完整性和一致性。

### 3.2 存储过程

数据库数据的增删改仅涉及到 `POST` 接口，故本部分主要列出 `POST` 接口对应的数据库存储过程的逻辑，同时也包括一些重要的 `GET` 接口的实现逻辑。

#### 3.2.1 用户管理

**注册**：

这一过程获取前端传来的数据，在 `User` 表中检查电话号码、邮箱、账号的唯一约束。如果错误则返回错误信息，否则随机生成唯一的 ID 填入 `User` 表中。

```python
@require_http_methods(["POST"])
def register(request):
    """ 用户注册 """
    data: dict = json.loads(request.body)
    account = data.get('account')
    phone_number = data.get("phone_number")
    email = data.get("email")
    if User.objects.filter(account=account).first():
        return JsonResponse({"msg": "账号已被注册", "status": False, "uid": "", "user_name": ""})
    elif User.objects.filter(Q(phone_number=phone_number) | Q(email=email)).first():
        return JsonResponse({"msg": "电话或邮箱已被注册", "status": False, "uid": "", "user_name": ""})
    else:
        uid = genid()
        password = data.get('password')
        user_name = data.get('user_name')
        user_age = data.get("user_age")
        user_gender = data.get("user_gender")
        user_signature = ""
        new_user = User(uid=uid, account=account, password=password, user_name=user_name,
                        user_age=user_age, user_gender=user_gender, phone_number=phone_number,
                        email=email, user_signature=user_signature)
        new_user.save()
        return JsonResponse({"msg": "注册成功", "status": True, "uid": uid, "user_name": user_name})
```

**登录**：

这一过程根据用户输入的账号密码，查找 `User`表是否有匹配的数据项，并将基本的用户信息返回给前端。

```python
@require_http_methods(["GET"])
def login(request):
    """ 用户登录验证 """
    account = request.GET.get('account')
    password = request.GET.get('password')
    user = User.objects.filter(account=account, password=password).first()
    if user:
        return JsonResponse({"msg": '登录成功', "status": True, "uid": user.uid, "user_name": user.user_name,
                             "picture": user.picture.url if user.picture else None})
    else:
        return JsonResponse({"msg": '登录失败', "status": False, "uid": None, "user_name": None})
```

**修改个人信息**：

这一过程用于修改用户个人的信息，由于用户输入的数据并不确定，为了保证数据库约束完整，需要对用户修改的电话号码、邮箱信息进行检查，如果已存在则返回错误，否则将新的数据写入 `User`表对应表项中。

```python
@require_http_methods(["POST"])
def modify_text(request):
    """ 修改个人信息 """
    req: dict = json.loads(request.body)
    print(req)
    user = User.objects.get(uid=req.get('uid'))
    # 数据库约束检查
    phone_number = req.get('data').get('phone_number')
    email = req.get('data').get('email')
    if phone_number and phone_number != user.phone_number:
        if User.objects.filter(phone_number=phone_number).first():
            return JsonResponse({"msg": "电话号码已存在", "status": False})
    if email and email != user.email:
        if User.objects.filter(email=email).first():
            return JsonResponse({"msg": "邮箱已存在", "status": False})

    for (key, value) in req.get('data').items():
        print(key, value)
        setattr(user, key, value)
    user.save()
    return JsonResponse({"msg": "个人信息修改成功", "status": True})
```

**上传用户头像**：

利用 Django 框架上传用户头像，将图片路径存入到 `User` 表的 `picture` 字段里。

```python
@require_http_methods(["POST"])
def modify_pic(request):
    """ 修改个人头像 """
    print(request.POST)
    user = User.objects.get(uid=request.POST.get('uid'))
    user.picture = request.FILES['picture']
    user.save()
    return JsonResponse({"msg": "头像已更新", "status": True})
```

**获取用户参加的团体**：

`UserInGroup` 表和 `Group `表依据团体 ID 进行自然连接，以用户 ID 查找相关数据项，并把团体的基本信息以数组形式返回给前端进行展示。

```python
@require_http_methods(["GET"])
def group_list(request):
    """ 查看用户所属团体 """
    uid = request.GET.get('uid')
    lst = list(map(lambda param: {'gid': param.gid.gid, 'group_name': param.gid.group_name,
                                  'group_desc': param.gid.group_desc, 'tag': param.gid.tag,
                                  'capacity': param.gid.capacity, 'maximum': param.gid.maximum,
                                  'creator': param.gid.creator.user_name,
                                  'pic': param.gid.picture.url if param.gid.picture else None,
                                  "type": param.get_type_display()},
                   user_group.search_relation(uid, None)))
    print(lst)
    return JsonResponse({"msg": '团体信息请求成功', "status": True, "list": lst})
```

**获取用户参加的活动**：

`UserInActivity` 表、 `Activity` 表和 `ActivityUseField`表按照活动 ID 进行自然连接，以用户 ID 查找相关数据项。将查询结果的活动基本信息以数组形式返回给前端进行展示。

```python
@require_http_methods(["GET"])
def activity_list(request):
    """ 查看用户参加的活动 """
    uid = request.GET.get('uid')
    user = User.objects.get(uid=uid)
    activities = set()
    liked_activities = set()
    for rec in UserInActivity.objects.filter(uid=user):
        if rec.like:
            liked_activities.add(rec.aid)
        activities.add(rec.aid)
    lst = list(map(lambda param: {"aid": param.aid.aid, "name": param.aid.name, 
                                  "type": param.aid.get_type_display(),
                                  "private": param.aid.private, "category": param.aid.category,
                                  "capacity": param.aid.capacity, "maximum": param.aid.maximum,
                                  "picture": param.aid.picture.url if param.aid.picture else None,
                                  "start_time": param.start_time.strftime("%Y-%m-%d %H:%M:%S"),
                                  "end_time": param.end_time.strftime("%Y-%m-%d %H:%M:%S"),
                                  "favor": param.aid.favor, "is_favor": param.aid in liked_activities},
                   ActivityUseField.objects.filter(aid__in=activities).order_by('-start_time')))
    print(lst)
    return JsonResponse({"msg": '活动信息获取成功', "status": True, "list": lst})
```

#### 3.2.2 团体模块

**创建团体**：

这一过程检查 `Group`表中团体名的唯一性约束是否满足，如果失败则返回错误信息，成功则插入新的团体信息，并且将团体创建者 ID 和 团体 ID 的联系填入 `UserInGroup` 表中。

```python
def create(request):
    """ 用户创建团体 """
    if request.method == 'POST':
        data = request.POST
        print(data)
        uid = data.get("uid")
        group_name = data.get("group_name")
        group_desc = data.get("group_desc")
        maximum = data.get("maximum")
        tag = data.get("tag")

        if Group.objects.filter(group_name=group_name):
            return JsonResponse({"msg": "团体名称已被使用", "status": False})
        else:
            # 添加团体信息
            gid = genid()
            creator = User.objects.get(uid=uid)
            new_group = Group(gid=gid, creator=creator, group_name=group_name, group_desc=group_desc,
                              tag=tag, maximum=maximum, capacity=0, picture=request.FILES['picture'])
            new_group.save()
            # 添加用户团体联系
            user_group.add_relation(uid, gid, 0)
            return JsonResponse({"msg": "团体创建成功", "status": True, "group_name": group_name, "gid": gid})
    else:
        return JsonResponse({"msg": "请求方式有误", "status": False})
```

**查看团体**：

这一过程允许用户通过关键字搜索，因此在 `Group` 表中按照类似于 ` MySQL` 中的 `in` 运算符进行模糊搜索，将获取的团体基本信息以列表的形式返回给前端。

```python
@require_http_methods(["GET"])
def view(request):
    """ 用户查看团体中心综述 """
    key = request.GET.get('keyword') or ''
    uid = request.GET.get('uid')
    groups = Group.objects.filter(
        Q(group_name__icontains=key) | Q(group_desc__icontains=key) | Q(tag__icontains=key)
    )
    joined_groups = list(map(lambda param: param.gid.gid, user_group.search_relation(uid, None)))

    lst = list(map(lambda param: {"gid": param.gid, "group_name": param.group_name, 
                                  "group_desc": param.group_desc,
                                  "tag": param.tag, "capacity": param.capacity, "maximum": param.maximum,
                                  "creator": param.creator.user_name, "is_joined": param.gid in joined_groups,
                                  "pic": param.picture.url if param.picture else None},
                   groups))

    return JsonResponse({"msg": "团体信息请求成功", "status": True, "list": lst})
```

**申请加入团体**：

这一过程首先需要到数据库中检查申请的有效性：一是到 `Group`表中找到对应团体，比较成员人数和最大人数限制，如果人数已达上限，则申请失败。第二是查找 `UserApplyGroup`表，查找是否存在用户向该团体的审核处于正在进行的状态，有则申请失败。

如果申请成功则向 `UserApplyGroup`表中

```python
@require_http_methods(["POST"])
def join(request):
    """ 用户申请加入团体 """
    data: dict = json.loads(request.body)
    print(data)
    uid = data.get("uid")
    gid = data.get("gid")
    content = data.get("content")
    msg, status = user_group.add_apply(uid, gid, content)
    return JsonResponse({"msg": msg, "status": status})

def add_apply(uid, gid, content):
    """ 增加用户申请团体信息 """
    user = User.objects.get(uid=uid)
    group = Group.objects.get(gid=gid)

    if group.maximum == group.capacity:
        return "团体人数已达上限", False
    if UserApplyGroup.objects.filter(uid=user, gid=group, status=0).first():
        return "已有申请正在审核中，请耐心等待", False
    else:
        apply = UserApplyGroup(uid=user, gid=group, content=content, status=0)
        apply.save()
        for rec in UserInGroup.objects.filter(Q(gid=group) & Q(Q(type=0) | Q(type=1))):
            notice.add_notice_to_user(rec.uid, user.user_name + "申请加入团体" + group.group_name)
        return "申请信息已发送", True
```

**查看团队申请**：

查看团队申请包括用户发送的请求和自己管理团体收到的请求。对于前者，以用户 ID 到 `UserApplyGroup` 表查找相应的数据项；对于后者，将 `UserInGroup` 表和 `UserApplyGroup` 表依据团队 ID 作自然连接，以依据用户ID，查找成员类型是创建者或管理员的团队的申请记录，并根据申请时间逆序排序。

```python
@require_http_methods(["GET", "POST"])
def apply(request):
    if request.method == 'GET':
        """ 查看团体申请信息 """
        uid = request.GET.get('uid')
        method = request.GET.get('method')
        lst = []

        if method == "accept":
            applies = user_group.search_accept_apply(uid)
            for a in applies:
                temp = {"uid": a.uid.uid, "user_name": a.uid.user_name, "content": a.content,
                        "gid": a.gid.gid, "group_name": a.gid.group_name,
                        "time": a.apply_time.strftime("%Y-%m-%d %H:%M:%S"),
                        "status": a.get_status_display()}
                lst.append(temp)

        elif method == "send":
            applies = user_group.search_send_apply(uid)
            for a in applies:
                temp = {"gid": a.gid.gid, "group_name": a.gid.group_name, "content": a.content,
                        "time": a.apply_time.strftime("%Y-%m-%d %H:%M:%S"),
                        "status": a.get_status_display()}
                lst.append(temp)
        else:
            return JsonResponse({"msg": "method参数错误", "status": False})
```

**审批团体申请**：

这一过程根据申请时间、团队ID、申请人ID 到 `UserApplyGroup` 表中查到指定记录，并将审核结果填入表中，把审核情况填入到通知表 `Notice` 中。对于团体人数已达上限的申请，同意会返回错误。最终被同意的申请，会将用户-团体联系添加到 `UserInGroup` 表中，并维护 `Group` 表的人数属性。

```py
@require_http_methods(["GET", "POST"])
def apply(request):
    if request.method == 'POST':
        """ 处理团体申请 """
        data: dict = json.loads(request.body)
        print(data)
        if user_group.modify_apply(data.get('uid'), data.get('gid'), data.get('res')):
            return JsonResponse({"msg": "处理完成", "status": True})
        else:
            return JsonResponse({"msg": "团体人数已达上限", "status": False})
```

**退出团体**：

这一过程依据用户 ID 和团体 ID 在 `UserInGroup` 表中查找记录，同时判断用户成员类型，如果是管理员或成员，则删除联系，将团体的人数属性减一；如果是创建人，则会解散团体，将团体从 `Group`表中删除，由于 Django 表设计时所有外键都设置了级联删除，因此会将有关的联系一并删去，保证了数据的一致性。

```python
@require_http_methods(["POST"])
def exit_out(request):
    """ 用户退出团体 """
    data: dict = json.loads(request.body)
    print(data)
    uid = data.get('uid')
    gid = data.get('gid')
    user_group.delete_relation(uid, gid)
    return JsonResponse({"msg": "团体已退出", "status": True})
```

**移除成员**：

这一部分依据用户ID、团体ID到 `UserInGroup`表查找数据删除，更新到系统通知表中，并更新团体的人数属性。

```py
@require_http_methods(["POST"])
def members_remove(request):
    """ 移除团体成员 """
    data: dict = json.loads(request.body)
    uid = data.get('uid')
    gid = data.get('gid')
    group = Group.objects.get(gid=gid)
    user_group.delete_relation(uid, gid)
    notice.add_notice_to_uid(uid, "很抱歉，您已被移出团体 (" + group.group_name + ")")
    return JsonResponse({"msg": "成员已移除", "status": True})
```

**修改成员权限**：

修改成员权限包括管理员到普通成员，普通成员到管理员两种操作。依据用户ID、团体ID到 `UserInGroup`表查找数据修改成员类型属性。

```python
@require_http_methods(["POST"])
def members_authority(request):
    data: dict = json.loads(request.body)
    uid = data.get('uid')
    gid = data.get('gid')
    member_type = data.get('type')
    if member_type == 0:
        return JsonResponse({"msg": "无法修改团体创建人信息", "status": False})
    elif member_type == 1:
        user_group.modify_relation(uid, gid, member_type)
        return JsonResponse({"msg": "添加团体管理员成功", "status": True})
    elif member_type == 2:
        user_group.modify_relation(uid, gid, member_type)
        return JsonResponse({"msg": "移除团体管理员成功", "status": True})
```

**查看团体活动**：

这一过程将 `Group`与 `GroupCreateActivity` 按照团队ID进行自然连接，查找指定团体的活动创建信息，并将活动的基本数据返回。

```python
def activity_list(request):
    """ 查看团体创建过的活动 """
    gid = request.GET.get('gid')
    group = Group.objects.get(gid=gid)
    activities = set(map(lambda param: param.aid, GroupCreateActivity.objects.filter(gid=group)))
    lst = list(map(lambda param: {"aid": param.aid.aid, "name": param.aid.name, 
                                  "type": param.aid.get_type_display(),
                                  "private": param.aid.private, "category": param.aid.category,
                                  "capacity": param.aid.capacity, "maximum": param.aid.maximum,
                                  "picture": param.aid.picture.url if param.aid.picture else None,
                                  "start_time": param.start_time.strftime("%Y-%m-%d %H:%M:%S"),
                                  "end_time": param.end_time.strftime("%Y-%m-%d %H:%M:%S"),
                                  "favor": param.aid.favor},
                   ActivityUseField.objects.filter(aid__in=activities).order_by('-start_time')))
    print(lst)
    return JsonResponse({"msg": '活动信息获取成功', "status": True, "list": lst})
```

#### 3.2.3 活动模块

**创建活动**：

创建活动需要检查活动时间的合法性，根据场地ID到 `Field` 表查询场地开放时间进行比较，对于不允许同一时间段有多个活动的场地，还需要在 `ActivityUseField` 查找申请时段是否已经存在联系记录，如果有则表明场地已被占用。

检查完时间的合法性后，将活动基本信息填入 `Activity` 表中，并将申请用户与活动的联系添加到活动成员表。

对于个人活动，将创建信息填入到用户创建活动表中，对于团体活动将创建信息填入到团体创建活动表中。

```python
@require_http_methods(["POST"])
def create(request):
    """ 创建新的活动 """
    data = request.POST
    print(data)
    if int(data.get('maximum')) < 1:
        return JsonResponse({"msg": "活动人数至少为1", "status": False})
    # 检查场地是否被占用
    elif not activity_field.check_relation(data.get('fid'), data.get('start_time'), data.get('end_time')):
        return JsonResponse({"msg": "当前时段场地不开放或已被占用", "status": False})
    else:
        activity = Activity(aid=genid(), type=data.get('type'), name=data.get('name'), desc=data.get('desc'),
                            category=data.get('category'), tags=data.get('tags'), maximum=data.get('maximum'),
                            capacity=0, favor=0, private=data.get('private') == 'true',
                            picture=request.FILES['picture'])
        activity.save()
        # 添加场地使用记录
        activity_field.add_relation(activity.aid, data.get('fid'), data.get('start_time'), data.get('end_time'))

        # 添加创建信息
        if data.get('type') == '0':  # 个人
            user_activity.add_create_relation(data.get('uid'), activity.aid)
        elif data.get('type') == '1':  # 团体
            group_activity.add_create_relation(data.get('uid'), data.get('gid'), activity.aid)
        else:
            return JsonResponse({"msg": "type参数取值有误", "status": False})

        # 项目创建人参与活动
        user_activity.add_relation(data.get('uid'), activity.aid)
        return JsonResponse({"msg": "活动创建成功", "status": True})
```

**获取活动列表**：

这一过程为查询过程，允许用户以各种搜索条件获取活动列表。首先依据用户的搜索信息形成初步查询条件，`Activity` 与 `ActivityUseField`自然连接，在表中查找尚未开始的活动，并且依据活动的开放属性，选择对用户可见的活动进行展示。

```python
@require_http_methods(["GET"])
def active(request):
    """ 查看当前可见的有效活动 """
    uid = request.GET.get('uid')
    time = request.GET.get('time', '')
    text = request.GET.get('text', '')
    category = request.GET.get('category', '')
    tag = request.GET.get('tag', '')
    activity_type = int(request.GET.get('type'))

    query = Q(start_time__gt=timezone.now())
    if time:
        query &= Q(start_time__date=parse_date(time))
    if text:
        query &= Q(Q(aid__name__icontains=text) | Q(aid__desc__icontains=text))
    if category:
        query &= Q(aid__category__icontains=category)
    if tag:
        query &= Q(aid__tags__icontains=tag)
    if activity_type != 2:
        query &= Q(aid__type__icontains=activity_type)
    records = ActivityUseField.objects.filter(query).order_by('start_time')
    lst = []
    groups = list(map(lambda param: param.gid, user_group.search_relation(uid, None)))
    actives = list((map(lambda param: param.aid, UserInActivity.objects.filter(uid=uid))))
    for record in records:
        flag = False
        if record.aid.type == 0:  # 个人
            if not record.aid.private or UserCreateActivity.objects.filter(aid=record.aid, uid=uid):
                flag = True
        elif record.aid.type == 1:  # 团体
            if not record.aid.private or GroupCreateActivity.objects.filter(aid=record.aid, gid__in=groups):
                flag = True

        if flag:
            lst.append({
                "aid": record.aid.aid,
                "name": record.aid.name,
                "type": record.aid.get_type_display(),
                "category": record.aid.category,
                "capacity": record.aid.capacity,
                "maximum": record.aid.maximum,
                "start_time": record.start_time.strftime("%Y-%m-%d %H:%M:%S"),
                "end_time": record.end_time.strftime("%Y-%m-%d %H:%M:%S"),
                "picture": record.aid.picture.url if record.aid.picture else None,
                "is_joined": record.aid in actives
            })

    return JsonResponse({"msg": "活动信息获取成功", "status": True, "list": lst})
```

**活动详情**：

这一过程将 `Activity` 表与 `UserInActivity` 表、`ActivityUseField`表作自然连接，查询指定活动的具体信息和参与成员信息。

```python
@require_http_methods(["GET"])
def detail(request):
    """ 查看活动的详细信息 """
    activity = Activity.objects.get(aid=request.GET.get('aid'))
    field_usage = ActivityUseField.objects.get(aid=activity)
    participants = list(
        map(lambda param: {"picture": param.uid.picture.url if param.uid.picture else None,
                           "uid": param.uid.uid, "user_name": param.uid.user_name,
                           "gender": param.uid.user_gender},
            UserInActivity.objects.filter(aid=activity))
    )
    data = {
        "aid": activity.aid,
        "type": activity.get_type_display(),
        "activity_name": activity.name,
        "desc": activity.desc,
        "category": activity.category,
        "tags": activity.tags.split('-'),
        "capacity": activity.capacity,
        "maximum": activity.maximum,
        "picture": activity.picture.url if activity.picture else None,
        "start_time": field_usage.start_time.strftime("%Y-%m-%d %H:%M:%S"),
        "end_time": field_usage.end_time.strftime("%Y-%m-%d %H:%M:%S"),
        "location": field_usage.fid.location,
        "favors": activity.favor,
        "participants": participants,
    }

    if activity.type == 0:  # 个人
        creation = UserCreateActivity.objects.get(aid=activity)
        data['uid'] = creation.uid.uid
        data['user_name'] = creation.uid.user_name
    else:  # 团体
        creation = GroupCreateActivity.objects.get(aid=activity)
        data['uid'] = creation.uid.uid
        data['user_name'] = creation.uid.user_name
        data['gid'] = creation.gid.gid
        data['group_name'] = creation.gid.group_name

    return JsonResponse({"msg": "活动详细信息获取成功", "status": True, "data": data})
```

**加入活动**：

这一过程和用户参加团体类似，在 `Activity`表查看活动的成员数量是否已达到上限，是则返回错误信息，否则增加成员人数，并将用户-团体联系添加到 `UserInGroup`表中。

```python
@require_http_methods(["POST"])
def join(request):
    """ 用户加入活动 """
    data: dict = json.loads(request.body)
    uid = data.get('uid')
    aid = data.get('aid')
    if user_activity.add_relation(uid, aid):
        return JsonResponse({"msg": "成功加入活动", "status": True})
    else:
        return JsonResponse({"msg": "人数已达上限", "status": False})
```

**退出活动**：

退出活动到 `Activity` 表找到数据项，判断用户是否为活动的创建者，如果不是则删除 `UserInGroup`表的联系，如果是则将活动信息移除活动表，由于外键设置了级联删除，先关联系会一并清除，保证数据库数据的一致性。

```python
@require_http_methods(["POST"])
def exit_out(request):
    """ 用户退出、撤销活动 """
    data: dict = json.loads(request.body)
    uid = data.get('uid')
    aid = data.get('aid')
    user_activity.delete_relation(uid, aid)
    return JsonResponse({"msg": "活动已退出", "status": True})
```

**发布活动动态**：

这一过程为用户对已参与并已结束的活动发布动态感想。

将活动 ID、用户ID、图片、文本和权限、发布时间写入到动态表中。

```python
@require_http_methods(["POST"])
def publish(request):
    """ 用户发布动态 """
    data = request.POST
    user = User.objects.get(uid=data.get('uid'))
    activity = Activity.objects.get(aid=data.get('aid'))
    if request.FILES.get('picture'):
        new_stream = Stream(sid=genid(), text=data.get('text'), picture=request.FILES['picture'],
                            favor=0, private=data.get('private'), user=user, activity=activity)
        new_stream.save()
    else:
        new_stream = Stream(sid=genid(), text=data.get('text'), favor=0, private=data.get('private'),
                            user=user, activity=activity)
        new_stream.save()
    return JsonResponse({"msg": "动态发布成功", "status": True})
```

#### 3.2.5 社区好友系统

**用户搜索**：

这一过程在 `User`表中根据关键字信息进行筛选，然后在 `friend`表中分别查找 uid1 是用户 ID 或 uid2 是用户 ID 的联系，标记是否是用户好友，返回用户信息列表。

```python
@require_http_methods(["GET"])
def find(request):
    """ 查询用户 """
    key = request.GET.get('keyword', '')
    if key == '':
        lst = []
    else:
        users = User.objects.filter(user_name__icontains=key)
        friends = friend.search_relation(request.GET.get('uid'))
        lst = list(map(lambda param: {'uid': param.uid, 'user_name': param.user_name,
                                      "pic": param.picture.url if param.picture else None,
                                      "signature": param.user_signature, "is_friend": param in friends},
                       users))
    print(lst)
    return JsonResponse({"msg": '用户信息搜索成功', "status": True, "list": lst})
```

**申请好友**：

这一过程首先到好友申请表中查询是否存在同一用户联系并且状态为正在审核，如果有返回错误信息，否则将申请者 ID 和接收者 ID 以及申请内容，申请时间填入好友申请表里，并标记状态为审核中，然后填入系统通知表中通知给接收用户。

```python
@require_http_methods(["POST"])
def friend_add(request):
    """ 申请添加好友 """
    data: dict = json.loads(request.body)
    sender = data.get('sender')
    receiver = data.get('receiver')
    content = data.get('content')
    msg, status = friend.add_apply(sender, receiver, content)
    return JsonResponse({"msg": msg, "status": status})
```

**查看好友申请**：

这一过程和查看团体申请比较类似，区分用户发送或接受的申请信息，并按照申请时间逆序排序输出返回给前端。

**处理好友申请**：

这一过程在好友申请表中查询对应的，状态为 "正在审核" 的记录，然后根据用户审核操作修改状态，并将信息添加到通知表中发送给申请用户。如果用户审核操作为同意申请，则将申请用户和接收用户的ID填入到 `friend` 表中，有且仅填写一直，保证数据约束完整。

```python
@require_http_methods(["POST", "GET"])
def friend_apply(request):
    if request.method == 'POST':
        """ 处理好友申请 """
        data: dict = json.loads(request.body)
        friend.handle_apply(data.get('sender'), data.get('receiver'), data.get('res'))
        return JsonResponse({"msg": "处理完成", "status": True})
```

**获取好友列表**：

根据用户ID 到好友联系表中进行查询。需要查询两次，一次查询条件 `uid1=id`，一次是 `uid2=id`，并且根据关键字进行筛选，最后把结果返回给前端。

```python
@require_http_methods(["GET"])
def friend_list(request):
    """ 好友列表 """
    uid = request.GET.get('uid')
    keyword = request.GET.get('keyword', '')
    lst = []
    for param in friend.search_relation(uid):
        if keyword in param.user_name:
            lst.append({'uid': param.uid, 'user_name': param.user_name,
                        "pic": param.picture.url if param.picture else None,
                        "signature": param.user_signature})
    return JsonResponse({"msg": '好友列表请求成功', "status": True, "list": lst})
```

**删除好友**：

删除好友这一过程以用户 ID 和好友 ID 到 `friend` 表中查询对应联系，找到删除，然后写入该结果信息到 `notice` 表中。

```python
@require_http_methods(["POST"])
def friend_delete(request):
    """ 用户删除好友 """
    data: dict = json.loads(request.body)
    print(data)
    uid = data.get('uid')
    fid = data.get('fid')
    friend.delete_relation(uid, fid)
    return JsonResponse({"msg": '好友删除完成', "status": True})
```

**获取动态列表**：

首先在好友表中找到指定用户 ID 的好友信息，然后将用户表、动态表、活动表作自然连接，对其进行查询。根据动态的权限查询出用户可见的动态信息，具体包括公开的动态、存在好友联系且仅好友可见的动态。

```python
@require_http_methods(["GET"])
def view(request):
    """ 查看动态列表 """
    user = User.objects.get(uid=request.GET.get('uid'))
    time = request.GET.get('time', '')
    query = Q()
    if time:
        query &= Q(time__date=parse_date(time))
    # 好友
    friends = friend.search_relation(request.GET.get('uid'))
    # 可见的动态
    streams = set()
    for rec in Stream.objects.filter(query).order_by('-time'):
        if rec.user == user:
            streams.add(rec)
        elif rec.private == 1 and rec.user in friends:
            streams.add(rec)
        elif rec.private == 2:
            streams.add(rec)

    lst = list(map(lambda param: {"owner": {"check": param.user == user, "name": param.user.user_name,
                                            "picture": param.user.picture.url if param.user.picture else None},
                                  "sid": param.sid, "time": param.time.strftime("%Y-%m-%d %H:%M:%S"),
                                  "text": param.text, "picture": param.picture.url if param.picture else None,
                                  "private": param.get_private_display(),
                                  "aid": param.activity.aid, "activity_name": param.activity.name},
                   streams))
    return JsonResponse({"msg": "动态列表获取成功", "status": True, "list": lst})
```

#### 3.2.6 器材借还系统

**获取器材列表**：

这一过程为查询过程，根据用户输入的关键字对 `equipment` 表进行查询，将所需字段内容投影返回给前端。

```python
@require_http_methods(["GET"])
def view(request):
    """ 查看器材信息 """
    key = request.GET.get('keyword', '')
    lst = list(map(lambda param: {"eid": param.eid, "category": param.category, "amount": param.amount,
                                  "pic": param.picture.url},
                   Equipment.objects.filter(category__icontains=key)))
    return JsonResponse({"msg": "器材信息请求成功", "status": True, "list": lst})
```

**租借器材**：

这一过程首先根据器材类别到 `equipment`表中进行查询，找到对应的器材实体记录，然后检查器材的剩余数量是否大于借用数量，不是则返回错误信息。然后区分用户借用和团体借用，到对应借用记录表中查询申请时段是否已经存在记录，如果存在则不允许多次借用，返回错误信息。对于检查可以借出的器材，将借用的时间，器材实体和用户实体/团体实体写入到对应借用记录表中，然后修改 `equipment`表的剩余数量属性。

```python
@require_http_methods(["POST"])
def borrow(request):
    """ 借用器材 """
    data: dict = json.loads(request.body)
    print(data)
    equipment = Equipment.objects.get(category=data.get("category"))
    start_time = datetime.strptime(data.get("start_time"), "%Y-%m-%d %H:%M:%S")
    end_time = datetime.strptime(data.get("end_time"), "%Y-%m-%d %H:%M:%S")

    if data.get("amount") > equipment.amount:
        return JsonResponse({"msg": "器材剩余数量不足", "status": False})

    if data.get("uid"):  # 用户借用
        user = User.objects.get(uid=data.get("uid"))
        if UserEquipment.objects.filter(eid=equipment, uid=user, start_time=start_time, 				                                               end_time=end_time).first():
            return JsonResponse({"msg": "同一时间段内已经存在同类借用记录", "status": False})

        new_record = UserEquipment(eid=equipment, uid=user, lend_amount=data.get("amount"),
                                   start_time=start_time, end_time=end_time)
        new_record.save()
    else:  # 团体借用
        group = Group.objects.get(gid=data.get("gid"))
        if GroupEquipment.objects.filter(eid=equipment, gid=group, start_time=start_time,
                                         end_time=end_time).first():
            return JsonResponse({"msg": "同一时间段内已经存在同类借用记录", "status": False})

        new_record = GroupEquipment(eid=equipment, gid=group, lend_amount=data.get("amount"),
                                    start_time=start_time, end_time=end_time)
        new_record.save()

    equipment.amount -= data.get("amount")
    equipment.save()
    return JsonResponse({"msg": "器材借用成功", "status": True})
```

**归还器材**：

这一过程根据用户 ID 或 团体 ID 以及借用器材的 ID 和借用的时间段到对应借用记录表进行检索，如果存在借用记录，则将其是否归还属性标记为已归还，否则返回错误信息。最后更新器材表对应器材实体的剩余数量属性。

```python
@require_http_methods(["POST"])
def give_back(request):
    """ 归还器材 """
    data: dict = json.loads(request.body)
    uid = data.get("uid")
    gid = data.get("gid")
    start_time = datetime.strptime(data.get("start_time"), "%Y-%m-%d %H:%M:%S")
    end_time = datetime.strptime(data.get("end_time"), "%Y-%m-%d %H:%M:%S")
    equipment = Equipment.objects.get(eid=data.get("eid"))

    if uid:  # 用户借用
        user = User.objects.get(uid=uid)
        borrow_record = UserEquipment.objects.filter(
            eid=equipment, uid=user, start_time=start_time, end_time=end_time).first()
    else:  # 团体借用
        group = Group.objects.get(gid=gid)
        borrow_record = GroupEquipment.objects.filter(
            eid=equipment, gid=group, start_time=start_time, end_time=end_time).first()

    if borrow_record:
        equipment.amount += borrow_record.lend_amount
        equipment.save()
        borrow_record.is_return = 2
        borrow_record.save()
        return JsonResponse({"msg": "器材归还成功", "status": True})
    else:
        return JsonResponse({"msg": "不存在借用记录", "status": False})
```

### 3.3 活动推荐

活动推荐顾名思义是向用户推荐活动，因此要针对指定用户实现个性化推荐，这也是后端比较有难度的部分，涉及大量的数据查询。

本项目的活动推荐鉴于课程主题并没有投入过多时间在于研究算法，而是依据常识理解根据数据库设计，获取相关数据信息进行整合，计算求权重然后排序。涉及的数据库操作如下：

首先获取用户可见的活动，即将  `Activity`、`ActivityUseField` 表自然连接，根据活动的起始时间、开放权限得到活动列表，同时将其创建者类型，人数规模，活动类型等记录起来。

然后在 `UserInActivity`、`UserCreateActivity `中计算所有用户的活跃度，即参加或创建的活动次数，以及在`GroupCreateActivity` 统计所有团体的活跃度，即创建的活动次数。

接着分析用户的喜好。基于本项目的数据库设计，用户的喜好可以依据其参加的活动类型、点赞过的活动类型、以及参加的活动的时间规律。目前该系统主要依据前面两部分，计算出每一种活动类型的权重，次数越高者权重越大。

有了上面查询的数据作基础，按照人数规模，创建者类型、创建者的活跃程度、用户喜好的活动类型等为每个可见的活动计算权值并逆序排序，取出前五个作为活动推荐的内容。

这一部分没有深究算法的合理性，因此实际应用效果并不理想，但非常考察队数据库的使用和查询。如何有效地在多个表中查询满足数据库约束的数据，以及如何加快查询效率都是需要思考的问题。

### 3.4 图片上传
在本项目中，有多处需要图片的地方，比如用户头像，活动照片等。在前端，我们使用 `FormData` 的格式，将图片视为文件，取出文件的`raw`属性作为参数返回给前端。
```javascript
const pic = this.form.pic[0].raw
const data = new FormData();
const uid = sessionStorage.getItem('uid');
data.append('group_name', this.form.name);
data.append('group_desc', desc);
data.append('maximum', this.form.max);
data.append('tag', this.form.tag);
data.append('picture', pic);

axios.post('http://127.0.0.1:8000/api/group/create', data)
  .then(response => {
    if (response.data.status) {
      this.$message.success('创建成功');
    } else {
      this.$message.error('创建失败，请重试');
    }
    this.getData();
})
```

后端使用了 Django ORM 框架的 `imageField `的字段存储图片信息。实际上是在后端项目中用 `media/images/`目录存储图片文件，而数据库相应字段则是用`varchar`类型存储文件相对地址，并作了相应的设置，开启后端后，可以在浏览器中根据图片 url 直接获取使用。

```python
#settings.py
MEDIA_ROOT = os.path.join(BASE_DIR, 'media').replace('\\', '/')
MEDIA_URL = '/media/'

#urls.py
urlpatterns = [
                  path('admin/', admin.site.urls),
                  path('api/', include('api.urls')),
              ] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
```

考虑到用户上传图片的文件名千奇百怪，为了统一管理，我们自定义`FileSystemStorage`子类，实现`_save`函数依据当前时间为文件重命名。

```python
class ImageStorage(FileSystemStorage):

    def __init__(self, location=settings.MEDIA_ROOT, base_url=settings.MEDIA_URL):
        super(ImageStorage, self).__init__(location, base_url)

    def _save(self, name, content):
        ext = os.path.splitext(name)[1]  # 文件扩展名
        d = os.path.dirname(name)  # 文件目录
        fn = time.strftime('%Y%m%d%H%M%S')  # 定义文件名，年月日时分秒随机数
        fn = fn + '_%d' % random.randint(0, 100)
        name = os.path.join(d, fn + ext)
        return super(ImageStorage, self)._save(name, content)
    
# 用户表
picture = models.ImageField(upload_to='images/user/', storage=ImageStorage())
```



### 3.5 面包屑

我们基于 `Vue` 和 `Element-Plus` 实现面包屑导航功能。它通过监听路由变化来更新面包屑导航的内容，保持与当前路由匹配的路径信息。

使用`el-breadcrumb` 和 `el-breadcrumb-item` 组件渲染面包屑导航。
```html
        <el-breadcrumb :separator-icon="ArrowRight" class="custom-breadcrumb">
            <el-breadcrumb-item :to="{ path: '/' }"></el-breadcrumb-item>
            <el-breadcrumb-item v-for="(item, index) in breadcrumbItems" :key="index">
                <router-link :to="item.to" class="custom-link"
                    :class="{ 'last-item': index === breadcrumbItems.length - 1 }">{{ item.label }}</router-link>
            </el-breadcrumb-item>
        </el-breadcrumb>
```

使用`watch`监听路由变化，根据当前路由的 `meta` 信息构建面包屑路径信息(在路由中配置了`meta.breadcrumbLabel`属性)。
```javascript
    watch: {
        $route(to, from) {
            // 监听路由变化，在路由变化时更新面包屑信息
            this.updateBreadcrumb(to.matched);
        }
    },
    methods: {
        updateBreadcrumb(matched) {
            // 根据当前路由的 meta 信息构建面包屑路径信息
            const breadcrumbs = [];
            matched.forEach(route => {
                if (route.meta && route.meta.breadcrumbLabel) {
                    breadcrumbs.push({
                        label: route.meta.breadcrumbLabel,
                        to: route.path
                    });
                }
            });
            this.breadcrumbItems = breadcrumbs;
        }
    }
```

## 四、系统实现结果

### 4.1 登录注册界面

#### 4.1.1 登录界面

<img src="images\登陆界面" alt="image-20231214225300614" style="zoom:50%;" />

- 输入账号、密码，如果存在此用户即可以成功登录。

- 如果没有账号或想创建一个新账号，可点击创建账号按钮进入注册账号界面。

#### 4.1.2 注册界面

<img src="images\注册界面_空白" alt="image-20231214230022686" style="zoom:50%;" />

- 输入账号、密码、真实姓名、性别、年龄、电话号码和电子邮箱。

- 错误处理为：年龄需要为数字、电话号码需要为11位数字、电子邮箱需要满足邮箱格式、其余内容需要存在。不符合格式的账号创建不被允许。

- 创建账号完成后，可点击上方“去登陆”回到登陆界面。

<img src="images\注册界面_错误处理" alt="image-20231214230526060" style="zoom:50%;" />

### 4.2 边栏

#### 4.2.1 侧边栏

<img src="images\侧边栏.png" alt="侧边栏" style="zoom:50%;" />

- 点击左上角蓝色按钮可以展开侧边栏，同时不展开当鼠标移动到侧边栏某一项时也会显示其内容。

- 从上到下侧边栏内容分别为：用户主页（默认）、活动列表、团体信息、我的活动、好友列表、器材租借和好友动态。

- 点击侧边栏即可进入对应的页面。

#### 4.2.2 上边栏

<img src="images\上边栏.png" alt="上边栏" style="zoom:50%;" />

- 上边栏展示的信息包括：网站logo、面包屑（体现当前的界面路径，点击“Home”可以回到登陆界面，点击某一级标签也可以回到该级界面）、查看通知按钮（点击可以处理通知）、头像和用户名。

#### 4.2.3 查看通知

<img src="images\查看通知.png" alt="查看通知" style="zoom:50%;" />

- 在查看通知界面中可以查看还未删除的所有通知信息，包括通知时间和通知内容。

- 点击删除通知可以删除单条通知。

- 点击删除所有通知可以一次性删除所有通知。

### 4.3 个人主页

#### 4.3.1 主界面

<img src="images\个人主页.png" alt="个人主页" style="zoom: 50%;" />

- 个人主页左侧能够显示个人基本信息，包括用户名、性别、个人签名、好友数、参加活动数、参加团体数、年龄、电话号码和个人邮箱。

- 点击“选择头像”可以从本地选择新的头像图片，再点击“点击上传”即可上传头像，刷新即可看到新头像。

- 点击“更改个人信息”能够更改一些个人信息，会进行后续说明。

- 右侧的表格可以显示当前已经参加的，不同类别活动的数量；也能显示当前已经参加的，不同标签的团体的数量。

#### 4.3.2 更新个人信息

<img src="images\更新个人信息.png" alt="更新个人信息" style="zoom:50%;" />

- 从个人主页的主界面点击“更改个人信息”可进入此界面。

- 进入界面时，默认内容为当前的个人信息。

- 更改个人信息后可以点击“确认更改”，如果没有出现错误（例如出现空信息），就会成功完成个人信息更改，可以在主界面看到更新。

- 注意，在刚创建账号时，个人签名默认为空，可以在此处进行初次设置。

### 4.4 活动信息

#### 4.4.1 热门活动

<img src="images\热门活动.png" alt="热门活动" style="zoom:50%;" />

- 在热门活动中，可以查看当前还没有开始的所有活动的基础信息。

- 在上部拥有一个走马灯，其中的图片都是系统经过推荐算法计算得出的，认为账号主任会感兴趣的活动，可以点击图片查看活动详情。

- 下面的未开始活动都会进行图片展示，同时点击下方按钮即可查看活动具体信息。

- 要注意，此处可能并不是所有的活动都会被展示，因为活动有公开和私人之分，例如一个私人的团体活动，其他未在这个团体中的账号就无法看到这个活动。

- 由于活动可能较多，本页面最下方设有分页器，可以进入较早的界面查看活动信息。

- 可以通过一些自定义参数来搜索特定活动。这些选择包括：选择活动的组织类型（个人、团体）、模糊搜索活动名称、搜索活动日期、搜索活动类型（由平台进行预设）、搜索活动标签。选择结束后点击查询即可查到符合这些参数的活动。

#### 4.4.2 过往活动

<img src="images\过往活动.png" alt="过往活动" style="zoom:50%;" />

- 在过往活动中可以看到所有已经结束的活动。

- 在过往活动界面中能直观看到一个活动的开始、结束时间、参与人数、人数容量、标签、名字以及点赞数。

- 也可以通过点击“查看详情”界面查看活动的详细信息。

- 同样可以在上部自定义搜索活动。自定义项和热门活动的参数基本一致（无法搜索标签），点击“查询”即可自定义搜索。

- 本界面还可以进行自定义排序，默认为时间排序，可以由用户选择变更为点赞数排序或人数规模排序，再点击“查询”即可完成自定义排序。

#### 4.4.3 活动详情

<img src="images\活动详情.png" alt="活动详情" style="zoom:50%;" />

- 在活动详情界面可以看到活动的所有信息，其中分为四个部分：左侧展示活动图片、中间展示基本信息、右侧展示参加用户、下侧展示活动简介。

- 如果本活动还没有开始，可以通过点击“加入活动”使号主加入活动（刷新后右侧参加用户会增加号主），如果已经结束，则加入活动键失效。

### 4.5 团体信息

#### 4.5.1 团体中心

<img src="images\团体中心.png" alt="团体中心" style="zoom:50%;" />

- 在团体中心界面中可以查看当前存在的所有团体（团体的查看不存在私密性）。

- 在左上角的“创建团体”可以使用，点击之后进入创建团体的界面。

- 右侧可以根据名字进行模糊搜索，搜索用户感兴趣的团体。

- 每个团体都可以看到名字、创建者、人数、容量。可以点击左侧“查看详情”来查看团体详情（进入团体详情页），也可以点击“申请加入”（进入申请加入团体页）。

- 同样，可以使用屏幕下方分页器进入不同页数查看团体情况。

#### 4.5.2 创建团体

<img src="images\创建团体.png" alt="创建团体" style="zoom:50%;" />

- 在团体中心点击“创建团体”后可进入本界面。

- 要想创建团体，需要正确填写团体名称（最长10字）、人数上限、标签（平台提供，可选择）、头像以及团体简介。正确填写后点击“提交”即可成功创建团体。

- 点击取消可以回到团体中心。

#### 4.5.3 申请加入团体

<img src="images\申请加入团体.png" alt="申请加入团体" style="zoom:50%;" />

- 在团体中心点击“申请加入”即可进入本界面。

- 写上想要给管理员看的申请内容后，点击“提交申请”即可。

- 点击“取消申请”可以回到团体中心。

#### 4.5.4 你的团体

<img src="images\你的团体.png" alt="你的团体" style="zoom:50%;" />

- 你的团体界面的构造基本和团体中心一致。能够查看团体图片、团体名、创建人、你在团体中的权限（创建人、管理员或普通成员）、可点击“查看详情”键查看团体详情（此处的团体详情和团体中心的查看详情略有不同，会进行后续说明）、查看当前团体人数和容量、点击退出团体。

#### 4.5.5 你的申请

<img src="images\你的申请.png" alt="你的申请" style="zoom:50%;" />

- 你的申请界面可以看到你申请加入其他团体的所有记录。

- 记录的内容包括你发起申请的时间、申请的目标团体和这条申请当前的申请状态。

- 本界面也拥有换页器，可以跳转到其他页数来查看更早的申请情况。

#### 4.5.6 代办审核

<img src="images\代办审核.png" alt="代办审核" style="zoom:50%;" />

- 代办审核界面能够看到你作为管理员或创建者的团体，其他用户对其发送的申请内容。

- 具体展示的内容包括：本条申请的申请日期、申请用户名、所申请的团体名、申请信息和申请状态。

- 当申请信息较大时无法在一行中显示，需要通过“点击展开”来查看完整的申请信息。

- 如果某条申请还没有被进行操作，则会出现“同意”和“拒绝”按钮，点击后即可同意或否定该条申请。

- 如果已经完成审核，则会显示该条审核是否被接受。

#### 4.5.7 团体详情

<img src="images\团体详情.png" alt="团体详情" style="zoom:50%;" />

- 在团体详情界面能看到本团体的所有信息，包括基本信息、承办活动信息、成员信息。

- 左侧会展示团体的图片及名字。

- 右上侧展现了团体所承办的所有活动信息，并统计了这些活动的类型并用饼状图展现，还展示了近期的活动的基本信息。

- 中下部点击团体简介即可展示创建者为团体写的简介（平时收起）。

- 点击其他成员即可进入成员展示管理界面。

#### 4.5.8 团体成员详情

<img src="images\团体成员详情.png" alt="团体成员详情" style="zoom:50%;" />

- 点击其他成员即可进入团体成员详情侧边栏，能看到其他成员的基本信息（昵称、头像、权限类型）

- 注意，在团体中心点击团体详情，再点击其他成员并没有操作选项，只有在我的团体中进行这些步骤才可以对其他成员进行操作。

- 点击“踢出”可以将其他成员踢出团体，点击“移除权限”可以移除一名成员的管理员权限，点击“设为管理员”可以把一名成员设定为管理员（当然这些操作也需要操作用户具有一定的权限）。

### 4.6 我的活动

#### 4.6.1 我的活动

<img src="images\我的活动.png" alt="我的活动" style="zoom:50%;" />

- 在我的活动界面中能看到用户从过去到将来参加的所有活动的信息。

- 对于已完成、未完成的活动，都可以看到活动名、活动时间、活动类型、活动容量和点赞数，也都可以通过“查看详情”键点击跳转到活动详情。

- 对于未开始的活动，可以通过“退出/撤销活动”按钮退出活动。如果用户是创建者，则活动会被撤销。

- 对于已完成的活动，可以通过右上角点赞/取消点赞（每个人只能点一个赞，会通过颜色显示是否已经点赞），同时可以通过“发布活动动态”按钮发布有关这个活动的活动动态。

- 同样的，界面底部拥有分页器，可以跳转到其他页码。

#### 4.6.2 申请活动

##### 4.6.2.1 填写基本信息

<img src="images\填写基本信息.png" alt="填写基本信息" style="zoom:50%;" />

- 申请活动的第一步就是要填写基本信息。

- 要注意，在输入活动标签之后，点击添加，这个标签才能被成功添加到活动中，同时标签可以添加多个。

- 活动图片在选择后还需要点击“更新图片”才能真正完成确定和上传。

- 将所有内容填写完成后才能点击“去选择场地”，否则系统会报错。

##### 4.6.2.2 选择时间、场地类型

<img src="images\选择时间、场地类型.png" alt="选择时间、场地类型" style="zoom:50%;" />

- 完成了基本信息的填写就可以开始确定时间和场地类型。

- 界面上方可以完成活动时间的选择，要选择活动的日期，和具体的时间区间。

- 在下面可以选择查询要借用的场地类型，点击查询后即可看到该类型的场地信息。

##### 4.6.2.3 选择场地

<img src="images\选择场地.png" alt="选择场地" style="zoom:50%;" />

- 显示刚才选择的场地类型下的所有场地信息。

- 在当前界面下可以看到的场地信息包括地址、开放时间。

- 可以点击“查看申请情况”查看该场地的更具体的活动申请情况。

##### 4.6.2.4 场地申请情况

<img src="images\场地申请情况.png" alt="场地申请情况" style="zoom:50%;" />

- 显示某一场地的具体申请借用情况

- 在上方可以选择某一天这一场地的申请借用情况，点击“查询”即可看到当天情况。

- 确认时间不冲突后，可以点击“选择场地”，相当于占用了这块场地在选定的活动时间内的时间。

- 在此处不进行时间冲突的错误处理，但保证如果时间冲突，活动申请不成功。

##### 4.6.2.5 申请活动反馈

<img src="images\申请活动反馈.png" alt="申请活动反馈" style="zoom:50%;" />

- 在完成上面的所有操作之后，平台会返回本次申请活动是否成功的反馈信息。在这个界面即可看到平台的反馈信息。

### 4.7 好友列表

#### 4.7.1 好友列表

<img src="images\好友列表.png" alt="好友列表" style="zoom:50%;" />

- 在好友列表中，用户可以看到所有好友的基本信息，包括头像、用户名和个人签名。

- 可以进行好友操作：点击右侧“删除好友”即可删除该好友。

- 拥有分页器，可以转移至其他页码查看更多好友基本信息。

- 点击右下角蓝色按钮，可以进入处理好友申请的界面。

- 点击右下角黄色按钮，可以进入添加好友界面。

#### 4.7.2 添加好友

<img src="images\好友申请.png" alt="好友申请" style="zoom:50%;" />

- 使用右上角的搜索栏进行想添加的用户搜索。此处的搜索为模糊搜索，能搜到包含输入字符串的所有用户名。

- 能看到符合搜索要求的用户的头像、用户名、个人签名信息。

- 点击”申请添加“按钮，就可以在弹出的界面中输入申请信息，再点击”提交申请“，这条信息即被传输给用户想加的好友。点击取消申请即返回不发送。

<img src="images\好友申请信息.png" alt="好友申请信息" style="zoom:50%;" />

#### 4.7.3 处理好友申请

##### 4.7.3.1 新的好友

<img src="images\新的好友.png" alt="新的好友" style="zoom:50%;" />

- 在好友列表界面点击黄色按钮即可默认进入此界面。

- 此界面中能看到已经处理的和还未处理的所有针对用户的好友申请信息。

- 无论是否已经处理，都能看到一条申请的申请时间、申请用户、申请信息这些信息。

- 对于已经完成处理的申请信息，会记录用户的处理方式（是否同意）。

- 对于未完成处理的申请信息，最右侧会出现”同意“和”拒绝“按钮，用户就可以在这里处理其他用户发来的好友请求（点击同意则加为好友，点击拒绝则不加为好友）。

##### 4.7.3.2 你的好友申请

<img src="images\你的好友申请.png" alt="你的好友申请" style="zoom:50%;" />

- 在好友申请界面能看到用户已经发出的好友申请。

- 界面能够展示的信息包括申请日期、申请对象和申请状态（状态包括申请中、已接受和未接受）。

### 4.8 器材租借

#### 4.8.1 器材借用

<img src="images\器材借用.png" alt="器材借用" style="zoom:50%;" />

- 器材借用界面中能够看到所有不同类型的器材的剩余数量情况。

- 对于每一种器材，下侧都拥有一个点击申请按钮，点击即可针对这种器材进行申请。

- 在左上角同样有搜索框，可以进行器材名的模糊搜索，用户可以使用搜索框来快速找到想要借用的器材类型。

#### 4.8.2 申请器材

<img src="images\申请器材.png" alt="申请器材" style="zoom:50%;" />

- 在器材借用界面中点击任意”点击申请“按钮即可进入本界面。

- 可以以个人、团体的名义申请器材。注意，如果是以团体的名义，只能以用户拥有权限的团体的名义（用户在团体中是创建者或管理员）。

- 填完所有信息且信息正确（例如器材余量充足，借用时间合法），点击”立即申请“即可成功申请器材。

#### 4.8.3 个人借用器材

<img src="images\个人借用器材.png" alt="个人借用器材" style="zoom:50%;" />

- 在个人借用界面能够看到所有自己以个人名义借出的器材信息。

- 一条借出信息包括：器材类型、借出数量、归还时间、归还状态。

- 归还状态包括未归还和已归还。我们的设定是：如果一个器材处于未归还且归还时间晚于当前时间的状态，都可以使用”归还器材“按钮在线上确认归还，如果超时则无法在线上完成，需要线下完成归还。

- 可以通过右上角的自定义搜索来搜索特定的器材记录。搜索参数包括器材类型、借用时间和归还状态。

- 可以通过分页器选择其他页码进行跳转查看。

#### 4.8.4 团体借用器材

<img src="images\团体借用器材.png" alt="团体借用器材" style="zoom:50%;" />

- 团体借用器材界面和个人借用器材界面基本一致。

- 差别是一条团体借出器材条目中还包含借用的团体名，也可以以借用团体名为参数查找借用器材记录。

- 注意，虽然只有管理员、创建者可以借出器材，但所有团体成员都有权力归还器材。也就是说，一旦一个团体的管理员借了器材，所有团体成员的团体借用器材界面都会多出一条记录。

### 4.9 好友动态

#### 4.9.1 动态广场

<img src="images\动态广场.png" alt="动态广场" style="zoom:50%;" />

- 在动态广场中能够看到所有用户有权限看到的，其他用户（包括用户自己）发送的动态。

- 一条动态的内容包括：发送用户的用户名和头像、发送时间、本动态基于的活动、动态照片、动态内容、点赞人信息。

- 通过点击动态开头的紫色链接，可以查看这条动态基于的活动的详细信息。

- 点击下方的爱心可进行点赞和取消点赞。是否已点赞可通过爱心颜色区分。

- 如果是用户自身发送的动态，可点击右侧”删除动态“来删除本动态。

- 左上角切换器可切换动态广场展示方式，方式包括：只展示用户本身的动态和展示所有可见动态。

## 五、总结
